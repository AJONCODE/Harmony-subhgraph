type UniswapFactory @entity {
  # factory address
  id: ID!

  # pair info
  pairCount: Int!

  # total volume
  totalVolumeUSD: BigDecimal!
  totalVolumeETH: BigDecimal!

  # untracked values - less confident USD scores
  untrackedVolumeUSD: BigDecimal!

  # total liquidity
  totalLiquidityUSD: BigDecimal!
  totalLiquidityETH: BigDecimal!

  # transactions
  txCount: BigInt!
}



type Exchange @entity {
    id: ID!                                 # Uniswap Exchange address
    tokenAddress: Bytes!                    # Token address
    tokenSymbol: String                     # Can't always get this, since any contract can be a uniswap contract (no erc20 interface)
    tokenName: String                       # Can't always get this, since any contract can be a uniswap contract (no erc20 interface)
    tokenDecimals: Int                      # Can't always get this, since any contract can be a uniswap contract (no erc20 interface)
    fee: BigDecimal!                        # Always 0.3% for v1 uniswap
    version: Int!                           # V1 only right now
    startTime: Int!                         # Time exchange was created

    ethLiquidity: BigDecimal!               # Equals the liquidty provided. Will likely be different than ethBalance
    tokenLiquidity: BigDecimal!             # Equals the token liquidity provided. Will likely be different thatn tokenBalance
    ethBalance: BigDecimal!                 # Equals the ether balance of the contract
    tokenBalance: BigDecimal!               # Equals the token balance of the contract
    combinedBalanceInEth: BigDecimal!       # Equal to ethBalance + (tokenBalance/price). Stored to simplify users calculating their own personal return. because the ratio may have changes a lot in one direction
    combinedBalanceInUSD: BigDecimal!       # Equal to combinedBalanceInUSD * DAI/ETH
    totalUniToken: BigDecimal!              # Count of the unilying unitokens that represent liquidity provided ownership

    # Counting Events
    addLiquidityCount: BigInt!              # Count the number of times liquidity has been added
    removeLiquidityCount: BigInt!           # Count the number of times liquidity has been removed
    sellTokenCount: BigInt!                 # Count the number of times the tokens been sold
    buyTokenCount: BigInt!                  # Count the number of times the tokens been bought

    # Price values using eth
    lastPrice: BigDecimal!                  # The last trade price
    price: BigDecimal!                      # Price is the total amount of tokens that equal one ETH. i.e. if ETH was 100 USD, price for DAI would be 100
    tradeVolumeToken: BigDecimal!           # Total tokens traded EVER
    tradeVolumeEth: BigDecimal!             # Total eth traded EVER
    tradeVolumeUSD: BigDecimal!             # Total USD traded EVER, accumulated at each trade with current token usd price * amount
    totalValue: BigDecimal!                 # totalValue is accumulation of trade price * trade volume. i.e. TV = tokensSold * priceTokensSold
    weightedAvgPrice: BigDecimal!           # Avg price of all trades since inception. WAP = totalValue / totalVolume

    totalTxsCount: BigInt!                  # Total tx count EVER

    # Price values uing usd
    lastPriceUSD: BigDecimal!               # The last trade price in USD
    priceUSD: BigDecimal!                   # USD / token
    weightedAvgPriceUSD: BigDecimal!        # weightAvgPriceUSD = ( $1 of ETH in ETH ) / weightedAvgPrice

    # Fields used to help derived relationship
    factory: Uniswap
    tokenHolders: [UserExchangeData!]       # Relationship to show all token holders on the exchange
}

type User @entity {
    id: ID!                         # user eth adddress
    exchangeBalances: [UserExchangeData!]!  @derivedFrom(field: "user")
}



type UserExchangeData @entity {
    id: ID!                         # ID is concatenation of token and user addr. i.e. 0xahiow4-0xkashkd34....
    userAddress: Bytes!
    user: User!
    exchange: Exchange!

    # Liquidity Provider Data
    ethDeposited: BigDecimal!       # where negative means eth was exchanged for tokens
    tokensDeposited: BigDecimal!    # Where negative means tokens were exchanged for eth
    ethWithdrawn: BigDecimal!
    tokensWithdrawn: BigDecimal!
    uniTokenBalance: BigDecimal!

    # Trading Data
    # Note - Fee is always charged in what the user is paying with. i.e. you buy eth by paying in token. Fee is in token
    # Note - ethBought, ethSold, tokensBought, and tokensSold are effected by a basic Transfer
    ethBought: BigDecimal!
    ethSold: BigDecimal!
    tokensBought: BigDecimal!
    tokensSold: BigDecimal!
    ethFeesPaid: BigDecimal!
    tokenFeesPaid: BigDecimal!
    ethFeesInUSD: BigDecimal!
    tokenFeesInUSD: BigDecimal!
}

enum EventType {
    AddLiquidity,
    RemoveLiquidity,
    TokenPurchase,
    EthPurchase
}





type Token @entity {
  # token address
  id: ID!

  # mirrored from the smart contract
  symbol: String!
  name: String!
  decimals: BigInt!

  # used for other stats like marketcap
  totalSupply: BigInt!

  # token specific volume
  tradeVolume: BigDecimal!
  tradeVolumeUSD: BigDecimal!
  untrackedVolumeUSD: BigDecimal!

  # transactions across all pairs
  txCount: BigInt!

  # liquidity across all pairs
  totalLiquidity: BigDecimal!

  # derived prices
  derivedETH: BigDecimal

  # derived fields
  tokenDayData: [TokenDayData!]! @derivedFrom(field: "token")
  pairDayDataBase: [PairDayData!]! @derivedFrom(field: "token0")
  pairDayDataQuote: [PairDayData!]! @derivedFrom(field: "token1")
  pairBase: [Pair!]! @derivedFrom(field: "token0")
  pairQuote: [Pair!]! @derivedFrom(field: "token1")
}

type Pair @entity {
  # pair address
  id: ID!

  # mirrored from the smart contract
  token0: Token!
  token1: Token!
  reserve0: BigDecimal!
  reserve1: BigDecimal!
  totalSupply: BigDecimal!

  # derived liquidity
  reserveETH: BigDecimal!
  reserveUSD: BigDecimal!
  trackedReserveETH: BigDecimal! # used for separating per pair reserves and global
  # Price in terms of the asset pair
  token0Price: BigDecimal!
  token1Price: BigDecimal!

  # lifetime volume stats
  volumeToken0: BigDecimal!
  volumeToken1: BigDecimal!
  volumeUSD: BigDecimal!
  untrackedVolumeUSD: BigDecimal!
  txCount: BigInt!

  # creation stats
  createdAtTimestamp: BigInt!
  createdAtBlockNumber: BigInt!

  # derived fields
  pairHourData: [PairHourData!]! @derivedFrom(field: "pair")
  mints: [Mint!]! @derivedFrom(field: "pair")
  burns: [Burn!]! @derivedFrom(field: "pair")
  swaps: [Swap!]! @derivedFrom(field: "pair")
}


type Transaction @entity {
    id: ID!  # txn  hash concatenated with exchange - need this for token to token swaps
    exchangeAddress: Bytes!
    addLiquidityEvents: [AddLiquidityEvent!] @derivedFrom(field: "transaction")
    removeLiquidityEvents: [RemoveLiquidityEvent!] @derivedFrom(field: "transaction")
    tokenPurchaseEvents: [TokenPurchaseEvent!] @derivedFrom(field: "transaction")
    ethPurchaseEvents: [EthPurchaseEvent!] @derivedFrom(field: "transaction")
    block: Int!
    timestamp: Int!
    user: Bytes!
    fee: BigDecimal!
    mints: [Mint]!
    burns: [Burn]!
    swaps: [Swap]!
}

interface TransactionEvent {
  id: ID!
  transaction: Transaction!
  ethAmount: BigDecimal!
  tokenAmount: BigDecimal!
}

# Note - No fee to provide liqidity
type AddLiquidityEvent implements TransactionEvent  @entity {
    id: ID!                 # Incrementing ID, 1, 2, etc, as txhashes can contain multiple events
    transaction: Transaction!
    ethAmount: BigDecimal!
    tokenAmount: BigDecimal!
    uniTokensMinted: BigDecimal!
}

# Note - No fee to provide liqidity
type RemoveLiquidityEvent implements TransactionEvent @entity {
    id: ID!                 # Incrementing ID, 1, 2, etc, as txhashes can contain multiple events
    transaction: Transaction!
    ethAmount: BigDecimal!
    tokenAmount: BigDecimal!
    uniTokensBurned: BigDecimal!
}

type TokenPurchaseEvent implements TransactionEvent @entity {
    id: ID!                 # Incrementing ID, 1, 2, etc, as txhashes can contain multiple events
    transaction: Transaction!
    # Monetary Values. Positive or negative determined by the TradeType
    ethAmount: BigDecimal!
    tokenAmount: BigDecimal!
    tokenFee: BigDecimal!
    ethFee: BigDecimal!
}

type EthPurchaseEvent implements TransactionEvent @entity {
    id: ID!                 # Incrementing ID, 1, 2, etc, as txhashes can contain multiple events
    transaction: Transaction!
    # Monetary Values. Positive or negative determined by the TradeType
    ethAmount: BigDecimal!
    tokenAmount: BigDecimal!
    tokenFee: BigDecimal!
    ethFee: BigDecimal!
}

##### Below are entites specifically for uniswap historical data #####

# Historical data for each event of each exchange. Useful for creating graphs and data analysis
type ExchangeHistoricalData @entity {
    id: ID!
    exchangeAddress: Bytes!
    type: EventType!
    timestamp: Int!

    ethLiquidity: BigDecimal!               # Equals the liquidty provided. Will likely be different than ethBalance
    tokenLiquidity: BigDecimal!             # Equals the token liquidity provided. Will likely be different thatn tokenBalance
    ethBalance: BigDecimal!                 # Equals the ether balance of the contract
    tokenBalance: BigDecimal!               # Equals the token balance of the contract
    combinedBalanceInEth: BigDecimal!       # Equal to ethBalance + (tokenBalance/price). Stored to simplify users calculating their own personal return. because the ratio may have changes a lot in one direction
    combinedBalanceInUSD: BigDecimal!       # Equal to combinedBalanceInUSD * DAI/ETH.  USD price at time of transaction
    totalUniToken: BigDecimal!              # Count of the unilying unitokens that represent liquidity provided ownership

    tokenPriceUSD: BigDecimal!              # USD / token. USD price at time of transaction
    price: BigDecimal!                      # Price is the total amount of tokens that equal one ETH. i.e. if ETH was 100 USD, price for DAI would be 100

    tradeVolumeToken: BigDecimal!           # Total tokens traded EVER. i.e. cumulative
    tradeVolumeEth: BigDecimal!             # Total eth traded EVER. i.e. cumulative
    tradeVolumeUSD: BigDecimal!             # Total USD traded EVER - cumulative with price at time of trade

    totalTxsCount: BigInt!                  # Total tx count EVER
    feeInEth: BigDecimal!
}

# Data accumulated and condensed into day stats for each exchange
type ExchangeDayData @entity {
    id: ID!                                 # token address concatenated with unix date (Nov 2nd 2018 is 17837)
    date: Int!                              # starts on 1541116800 (Nov 2nd 2018 00:00:00). all dates must start on 00:00:00
    exchangeAddress: Bytes!
    ethBalance: BigDecimal!                 # Eth balance at last event within the day
    tokenBalance: BigDecimal!               # Token balance at last event within the day
    marginalEthRate: BigDecimal!            # tokenBalance / ethBalance
    ethVolume: BigDecimal!                  # Cumulative volume throughout the day
    tokenPriceUSD: BigDecimal!              # USD token price at last event within the day
    totalEvents: BigInt!
}

# Data accumulated and condensed into day stats for all of Uniswap
type UniswapDayData @entity {
    id: ID! # timestamp rounded to current day by dividing by 86400 - should only be one per day
    date: Int!

    dailyVolumeInETH: BigDecimal!
    dailyVolumeInUSD: BigDecimal!

    totalVolumeInEth: BigDecimal!           # volume just on eth -i.e. we dont double count volume
    totalLiquidityInEth: BigDecimal!        # 2 * SUM(exchanges.ethLiquidity). Since tokenLiquiduity = ethLiquidity value, can just *2
    totalVolumeUSD: BigDecimal!             # Accumulate at each trade, not just calculated off whatever totalVolume is. making it more accurate as it is a live conversion
    totalLiquidityUSD: BigDecimal!

    totalTokenSells: BigInt!                # Total events where tokens have been sold
    totalTokenBuys: BigInt!                 # Total events where tokens have been bought
    totalAddLiquidity: BigInt!              # Total events where liqidity has been added
    totalRemoveLiquidity: BigInt!           # Total events where liquidity have been removed

    txCount: BigInt!
}

# Data checkpointed at each timestamp for 24hour data
type UniswapHistoricalData @entity {
    id: ID!  # unique based on incremental entity count, one for each transactions
    timestamp: Int!

    totalVolumeInEth: BigDecimal!           # volume just on eth -i.e. we dont double count volume
    totalLiquidityInEth: BigDecimal!        # 2 * SUM(exchanges.ethLiquidity). Since tokenLiquiduity = ethLiquidity value, can just *2
    totalVolumeUSD: BigDecimal!             # Accumulate at each trade, not just calculated off whatever totalVolume is. making it more accurate as it is a live conversion
    totalLiquidityUSD: BigDecimal!

    totalTokenSells: BigInt!                # Total events where tokens have been sold
    totalTokenBuys: BigInt!                 # Total events where tokens have been bought
    totalAddLiquidity: BigInt!              # Total events where liqidity has been added
    totalRemoveLiquidity: BigInt!           # Total events where liquidity have been removed

    txCount: BigInt!
}

type Mint @entity {
  # transaction hash + "-" + index in mints Transaction array
  id: ID!
  transaction: Transaction!
  timestamp: BigInt! # need this to pull recent txns for specific token or pair
  pair: Pair!

  # populated from the primary Transfer event
  to: Bytes!
  liquidity: BigDecimal!

  # populated from the Mint event
  sender: Bytes
  amount0: BigDecimal
  amount1: BigDecimal
  logIndex: BigInt
  # derived amount based on available prices of tokens
  amountUSD: BigDecimal

  # optional fee fields, if a Transfer event is fired in _mintFee
  feeTo: Bytes
  feeLiquidity: BigDecimal
}

type Burn @entity {
  # transaction hash + "-" + index in mints Transaction array
  id: ID!
  transaction: Transaction!
  timestamp: BigInt! # need this to pull recent txns for specific token or pair
  pair: Pair!

  # populated from the primary Transfer event
  liquidity: BigDecimal!

  # populated from the Burn event
  sender: Bytes
  amount0: BigDecimal
  amount1: BigDecimal
  to: Bytes
  logIndex: BigInt
  # derived amount based on available prices of tokens
  amountUSD: BigDecimal

  # mark uncomplete in ETH case
  needsComplete: Boolean!

  # optional fee fields, if a Transfer event is fired in _mintFee
  feeTo: Bytes
  feeLiquidity: BigDecimal
}

type Swap @entity {
  # transaction hash + "-" + index in swaps Transaction array
  id: ID!
  transaction: Transaction!
  timestamp: BigInt! # need this to pull recent txns for specific token or pair
  pair: Pair!

  # populated from the Swap event
  sender: Bytes!
  from: Bytes! # the EOA that initiated the txn
  amount0In: BigDecimal!
  amount1In: BigDecimal!
  amount0Out: BigDecimal!
  amount1Out: BigDecimal!
  to: Bytes!
  logIndex: BigInt

  # derived info
  amountUSD: BigDecimal!
}

# stores for USD calculations
type Bundle @entity {
  id: ID!
  ethPrice: BigDecimal! # price of ETH usd
}

# Data accumulated and condensed into day stats for all of Uniswap
type UniswapDayData @entity {
  id: ID! # timestamp rounded to current day by dividing by 86400
  date: Int!

  dailyVolumeETH: BigDecimal!
  dailyVolumeUSD: BigDecimal!
  dailyVolumeUntracked: BigDecimal!

  totalVolumeETH: BigDecimal!
  totalLiquidityETH: BigDecimal!
  totalVolumeUSD: BigDecimal! # Accumulate at each trade, not just calculated off whatever totalVolume is. making it more accurate as it is a live conversion
  totalLiquidityUSD: BigDecimal!

  txCount: BigInt!
}

type PairHourData @entity {
  id: ID!
  hourStartUnix: Int! # unix timestamp for start of hour
  pair: Pair!

  # reserves
  reserve0: BigDecimal!
  reserve1: BigDecimal!

  # derived liquidity
  reserveUSD: BigDecimal!

  # volume stats
  hourlyVolumeToken0: BigDecimal!
  hourlyVolumeToken1: BigDecimal!
  hourlyVolumeUSD: BigDecimal!
  hourlyTxns: BigInt!
}

# Data accumulated and condensed into day stats for each exchange
type PairDayData @entity {
  id: ID!
  date: Int!
  pairAddress: Bytes!
  token0: Token!
  token1: Token!

  # reserves
  reserve0: BigDecimal!
  reserve1: BigDecimal!

  # total supply for LP historical returns
  totalSupply: BigDecimal!

  # derived liquidity
  reserveUSD: BigDecimal!

  # volume stats
  dailyVolumeToken0: BigDecimal!
  dailyVolumeToken1: BigDecimal!
  dailyVolumeUSD: BigDecimal!
  dailyTxns: BigInt!
}

type TokenDayData @entity {
  id: ID!
  date: Int!
  token: Token!

  # volume stats
  dailyVolumeToken: BigDecimal!
  dailyVolumeETH: BigDecimal!
  dailyVolumeUSD: BigDecimal!
  dailyTxns: BigInt!

  # liquidity stats
  totalLiquidityToken: BigDecimal!
  totalLiquidityETH: BigDecimal!
  totalLiquidityUSD: BigDecimal!

  # price stats
  priceUSD: BigDecimal!
}
